# CS-320-Software-Testing
Project Two
	When it came to the first part of developing the contact service, I wasn’t sure where to start or even how to start but after reading and doing some research I decided to start by writing the code step by step per the customers requirements. I would write the code for the requirement and then I would write the test code for that requirement. Then I would run the test code to make sure that the base code passed. Once the base code passed the test code I would go back and write the base code for the next requirement, and I would repeat those steps until I had all the requirements covered. Once I know that each of the requirements were covered and their base codes had passed with the with codes. I would run the Junit coverage test to make sure that it had 100% coverage. If for sure reason it wasn’t at 100% coverage I would go back and find what wasn’t being covered and I would change the code. After I changed the code, I would run the Junit test again to make sure it was 100%, I would repeat this until my code was 100% covered. 
	The way that I made sure that my code was technically sound was that I would keep all the requirements in order in which they were giving to me in the assignment. I would also do my best to keep the requirements for each of the items within each assignment grouped into the same check functions as the following example of my updateNumber function will show: 
protected void updateNumber(String number) {
		String regex = "[0-9]+";

		if (number == null || number.length() != NUMBER_LENGTH) {
			throw new IllegalArgumentException("Invalid Phone Number.");
		} else if (!number.matches(regex)) {
			throw new IllegalArgumentException("Phone Number can only have numbers, try again.");
		} else {
			this.number = number;
		}

	}
In this example the requirements for updating the phone number were that it could only contain numbers no letters, it could not be null, and it had to be 10 digits long, no more and no less. And as you can see in the example, I told it that if the number was equal to null or the number length was not equal to 10 digits then it should throw an Illegal Argument Exception. I did the same thing when it came to seeing if there was any letter in the phone number. I would do this with all the code that I would write for those assignments and by doing this I was able to ensure that I was able to get all the requirements that the customer had asked for. 
	The way that I made sure that my code was efficient was that I made sure that all my code had easy readability and all my function names were well named, so that they would be easy for the next user to understand. In the following example you will see how the function names are easy to understand for anyone that looks at the code itself.   
 
As you can see from the example if someone besides me needed to go in and change how the first name is updated, they would know where they needed to go to change it. I did this with all the code that I wrote for those assignments. I wanted to make sure that anyone that looked at my code would be able to know how it worked and to make it easier to change in the future if it was needed.
	The technique that I used was to be organized, with a slow and steady pace. I would write the some of the main code based on the customer requirements. After I would complete the code for one requirement, I would then write the testing code for that requirement. I would then run the test code to see if I needed to change anything in my main code. If the test passed, I would move on to the next requirement and test code.
	Another technique that could be used would be the opposite of the one I used above, which would be to write all the main code based on customer requirements, and then write all the test code. With this technique you could still stay organized, but I believe that it would be a faster pace than writing one requirement at a time, but it would also make the likely hood of mistakes higher. The reason the likelihood of mistakes would be higher is because the more code you write before you running your test is more possibilities for some of your code to be wrong. 
	The practical uses and implications of the two techniques that I have discussed would depend what kind of time frame you had to complete your work. If you had the time then I would use the first technique that I discussed, by using this technique you get the chance to make sure that all your code is working in the way that you intended it to. But if the work you must do is on a strict deadline, then your best option would be to use the second technique to write all the main code before you start writing and using your test code. The only issue I have with this technique is that it leaves more room for error in your code. 
	The mindset that I adopted while working on this project as if I was a software tester, I tried to make sure to use caution to make sure to cover all the customer requirements. By doing this I was able to appreciate the complexity and interrelationship of the code, because it allowed me to take my time and pay attention to all the code while making sure that the requirements were met. 
	To try to limit the amount of bias that I had while I was acting as a software tester for this course. I tried to look at it as a switch in my head that I could turn on and off depending on if I was testing or developing code. When I was developing my code, I was doing the best I could to make sure that it was functional and worked the way that it should have. When I was testing my code, I would do my best to break the functionally of the code that I was testing. By doing this I was able to look at my code in two different perspectives. Through the eyes of a developer and a tester.
	The reason that I think it is important to be disciplined in my commitment to quality as a software engineering professional is that if you try to speed through it and cut corners when writing or testing code is that it could have endless possibilities of consequences that could range anywhere from releasing a product full of bugs, costing the company money, or in the worst case costing someone their live. So to make sure to avoid technical debt it is a good idea to follow good programming practices as well as to maintain a high percentage of testing coverage for must company’s that would mean that when running your Junit test you would need to maintain a coverage of above 80%. A few other ways to help avoid technical dept would be to create good documentation, make sure to take your time, and have great communication with all of your teams.
